# Mysql 数据库进阶学习笔记

> 本篇笔记基于《高性能MySQL 第3版》汇总而成，涉及 MySQL 内核部分，参考了《MySQL技术内幕 : InnoDB存储引擎 第2版》

## 1. MySQL 逻辑架构

### 1.1 架构分层

<img src="https://img-blog.csdn.net/20180831173911997?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pfcnlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="image-MySQL架构" style="zoom: 67%;" />

存储引擎架构分为三层，自上而下，分为 **第一层：连接层；第二层：服务层；第三层：引擎层**

这种架构将：**查询处理、其他系统任务、数据的存储与提取** 三部分分离。所以，带来的好处就是可以在使用时**根据性能、特性，以及其他需求来选择数据存储方式**。

#### 连接层

MySQL的最上层是连接服务，引入了线程池的概念，允许多台客户端连接。主要工作是：**连接处理、授权认证、安全防护等**。

连接层为通过安全认证的接入用户提供线程，同样，在该层上可以实现基于SSL 的安全连接。

#### 服务层

服务层用于处理核心服务，如标准的SQL接口、查询解析、SQL优化和统计、全局的和引擎依赖的缓存与缓冲器等等。所有的与存储引擎无关的工作，如过程、函数等，都会在这一层来处理。

在该层上，服务器会解析查询并创建相应的内部解析树，并对其完成优化，如确定查询表的顺序，是否利用索引等，最后生成相关的执行操作。如果是SELECT 语句，服务器还会查询内部的缓存。如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。

#### 引擎层

存储引擎层，存储引擎负责实际的MySQL数据的**存储与提取**，**服务器通过API 与 存储引擎进行通信**。

<br>

### 1.2 MySQL 工作流程

<img src="https://img-blog.csdnimg.cn/20191215175150258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9tb3J0eS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="image-MySQL工作流程" style="zoom: 80%;" />

**第一层：建立连接** 

1. 连接处理：客户端同数据库服务层建立 TCP 连接，连接层会请求一个连接线程。如果连接池中有空闲的连接线程，则分配给这个连接，如果没有，在没有超过最大连接数的情况下，创建新的连接线程负责这个客户端。 
2. 授权认证：在真正的操作之前，还需要调用用户模块进行授权检查，来验证用户是否有权限。通过后，连接线程开始接收并处理来自客户端的 SQL 语句。

**第二层：核心服务** 

1. 连接线程接收到 SQL 语句之后，将语句交给 SQL 语句解析模块进行语法分析和语义分析。
2. 如果是一个 SELECT 语句，则先查询缓存，如果有结果直接返回给客户端。
3. 如果查询缓存中没有结果，再查询数据库引擎层。先通过 SQL 优化器（Optimizer），进行查询的优化。

**第三层：数据库引擎层** 

1. 打开表，如果需要的话获取相应的锁。 
2. 先查询 **缓存页** 中有没有相应的数据，如果有则可以直接返回，如果没有就要从磁盘上去读取。
3. 当在磁盘中找到相应的数据之后，则会加载到缓存中来，从而使得后面的查询更加高效，由于内存有限，多采用变通的LRU表来管理缓存页。

最后，获取数据后返回给客户端，关闭连接，释放连接线程。

<br>

<br>

## 2. MySQL 存储引擎


### 2.1 MyISAM 和 InnoDB 的区别 
| 对比项 |           MyISAM           |              InnoDB              |
| :----: | :------------------------: | :------------------------------: |
| 主外键 |           不支持           |               支持               |
|  事务  |           不支持           |               支持               |
|   锁   |            表锁            |               行锁               |
|  缓存  | 只缓存索引，不缓存真实数据 | 缓存索引和真实数据，对内存要求高 |
| 表空间 |             小             |                大                |
| 关注点 |            性能            |               事务               |



* MyISAM

  * B+ Tree 索引文件和数据文件是分离的**（非聚集索引）**

  <img src="https://github.com/IvanBao97/Notes/blob/main/MySQL/NotePics/MyISAM.png" alt="image-MyISAM" style="zoom:50%;" />

* InnoDB

  * 表数据文件本身就是按 B+ Tree 组织的一个索引结构文件**（聚集索引）**
  * 叶节点包含了完整的数据记录

  <img src="https://github.com/IvanBao97/Notes/blob/main/MySQL/NotePics/InnoDB.png" alt="image-InnoDB" style="zoom:50%;" />

  

  * **InnoDB 表必须建立主键，并且推荐用整型的自增主键**
    1. 建立主键是为了方便使用主键索引去维护 B+ Tree
       * 如果没有建立主键，MySQL 会自动寻找一个数据不重复的字段列作为唯一索引，来维护 B+ Tree
       * 如果没有找到数据不重复的字段，MySQL 会自动添加一个唯一字段维护 B+ Tree
    2. 使用整型是因为方便查找时索引比较，且占用空间小
    3. 自增可以保证，新增元素可以直接插在叶子节点的最右边，从而不改变其他部分结构，因为叶子节点的索引值，从左到右依次增加

### 2.2 InnoDB 引擎结构
<img src="https://github.com/IvanBao97/Notes/blob/main/MySQL/NotePics/InnoDB%E5%BC%95%E6%93%8E%E7%BB%93%E6%9E%84.png" alt="image-InnoDBStructure" style="zoom:50%;" />

#### 2.2.1 线程
* Master Thread
	* 核心后台线程，负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性（包扩了下面三个线程的全部功能）
* IO Thread
	* Write Theard 写线程
	* Read Theard 读线程
	* Insert buffer Theard 处理插入缓冲线程
	* Log Theard 日志操作线程
* Purge Thread
	* 用来回收事务提交后，不再使用的 undo Log
* Page Cleaner Theard
	* 将内存缓冲池里的脏页刷新到磁盘文件

#### 2.2.2 内存
* 缓冲池
	* 作用：
		* 通过内存的速度来弥补磁盘速度较慢对数据库性能的影响
	* 读流程：
		* 进行读取页操作时，首先判断该页是否在缓冲池中，若存在，则命中；不存在，则从磁盘读取，并将该页存放在缓冲池中
	* 写流程：
		* 首先修改缓冲池中的页，然后以一定的频率刷新到磁盘上（并不是每次修改都出发刷新，而是通过 CheackPoint 机制刷新回磁盘）
	* CheackPoint 机制
		* 事务操作在写之前，会先记录 redo log，当之前的 redo log 过期时，将其记录的操作页刷回磁盘
		* LRU 淘汰页是脏页时，会触发 CheackPoint，将脏页刷回磁盘
	* 管理方式（Data Page）：
		* LRU with midPoint
			* 新访问的页放在 midPoint 而不是首部，防止由于全扫描使一些非热点数据页被插在首部，导致热点数据移除
		* Free List：
			* 存储空闲页。每当 LRU 需要加入新页时，先查询 Free List ，有空闲页，将新页直接插入 LRU，并删除一个空闲页；没空闲，采用 LRU 淘汰策略删除非热点页
		* Flush List：
			* LRU 中的页被修改后，被称为脏页，等待 CheckPoint 机制刷回磁盘。Flush List 存储了所有的脏页，管理脏页的刷新。同时，用户依旧可以在 LRU 中查看修改的页
	

#### 2.2.3 关键特性
* 插入缓冲（Insert Buffer）：
	* 对于非聚簇索引列插入数据时，因为不是自增列，会导致磁盘随机访问，降低性能
	* InnoDB 设置了插入缓冲，先在内存中预合并这些插入数据，再定期刷回磁盘，优化了非聚簇索引列数据的插入性能

* 两次写（Double Write）：
	* 解决页损坏时，数据丢失的问题（记录损坏可以通过 redo log 恢复）

* 自适应哈希索引（Adaptive Hash Index）：
	* InnoDB 存储引擎会监控各表索引页的查询，自动根据访问的频率和模式为某些热点页建立哈希索引
	* 条件：连续对某一模式访问100次 或 访问次数达到 N 次（N = 页记录 / 16）
	* Eg：对于(a, b) 这种联合索引，访问模式有以下两种：
		```sql
		WHERE a = xxx;
		WHERE a = xxx AND b = xxx;
		```

* 异步IO：
	* 通过 AIO 的方式同时扫描多个页，也可以将多个 IO 操作合并成一个

* 刷新临近页：
	* 当刷新一个脏页时，InnoDB 会检测该页所在区（extent）的所有页，如果是脏页，则一起刷新


#### 2.2.4 文件


<br>

<br>

## 3. Mysql 并发控制

### 3.1 锁

#### 2.1.1 锁的分类及特点

> 不同存储引擎的锁实现也不同，比如 MyISAM 只提供表锁，而 InnoDB 则还支持一致性非锁定读和行锁。
>
> 本笔记是基于 InnoDB 引擎展开的深入学习

##### Latch 和 Lock 的区别

* Latch 是轻量级锁，可分为 mutex（互斥量）和 rwlock（读写锁）。目的是保证并发县城操作资源的正确性，锁定时间短，通常没有死锁检测机制。
* Lock 的对象是事务，用来锁数据库的表、页、行。一般在事务的 commit 和 rollback 之后释放，有死锁检测机制。

|          |              Lock              |            Latch             |
| :------: | :----------------------------: | :--------------------------: |
|   对象   |              事务              |             线程             |
|   保护   |           表、页、行           |         内存数据结构         |
| 持续时间 |          整个事务过程          |           临界资源           |
|   模式   |       行锁、表锁、意向锁       |        读写锁、互斥量        |
|   死锁   | 有（通过 time out 等机制处理） | 无（可通过加锁顺序避免死锁） |
|  存在于  |     Lock Manager 的哈希表      |       数据结构的对象中       |



##### 行锁

* 共享锁（读锁）：允许事务读一行数据
* 排他锁（写锁）：允许事务删除或更新一条数据

##### 表锁

* 意向共享锁
* 意向排他锁

<br>

### 3.2 多版本并发控制





<br>

### 3.3 事务

#### 3.3.1 事务的 ACID 特性和隔离级别

##### 3.3.1.1 ACID 特性

* **原子性（Atomicity）**
  * 事务必须被视为一个不可分割的最小工作单元。其中的所有操作要么都提交成功，要么都失败回滚。
  * 通过 undo log 实现。（详见事物的实现篇）

* **一致性（Consistency）**
  * 事务必须将数据库从一种一致状态转变为另一种一致状态，数据库的完整性不会被破坏。
  * 数据库通过原子性、隔离性、持久性来保证一致性。C(一致性)是目的，A(原子性)、I(隔离性)、D(持久性)是手段。
* **隔离性（Isolation）**
  * 每个事务提交前，对其他事务都不可见。
  * 通常用锁和 MVCC 来实现。（详见锁篇）
* **持久性（Durability）**
  * 事务一旦提交，其操作结果就是永久性的。
  * 通过 redo log 实现。（详见事物的实现篇）

##### 3.3.1.2 隔离级别

- **读未提交（Read Uncommitted）**
  - 读未提交，任何操作都不加锁，所以能读到其他事务修改但未提交的数据行，也称之为脏读（Dirty Read）。
- **读已提交（Read Committed）**
  - 读操作不加锁，写操作加锁。读被加锁的数据时，读事务每次都读 undo log 中的最近版本，因此可能对同一数据读到不同的版本（不可重复读），但能保证每次都读到最新的数据（事务提交之后的，不可重复读，两次读不一致），但是不会在记录之间加间隙锁，所以允许新的记录插入到被锁定记录的附近，所以再多次使用查询语句时，可能得到不同的结果。
- **可重复读（Repeatable Read - InnoDB 引擎默认）**
  - 第一次读数据的时候就将数据加行锁（共享锁），使其他事务不能修改当前数据，即可实现可重复读。但是不能锁住 insert 进来的新的数据，当前事务读取或者修改的同时，另一个事务还是可以 insert 提交，造成幻读；
  - 注：mysql 的可重复读的隔离级别解决了 “不可重复读” 和 “幻读” 2 个问题，因为使用了间隙锁。
- **串行化（Serializable）**
  - InnoDB 锁表，读锁和写锁阻塞，强制事务串行执行，解决了幻读的问题



**隔离级别与问题对应表如下：**

| 隔离级别                     | 脏读（Dirty Read） | 不可重复读（NonRepeatable Read） | 幻读（Phantom Read） |
| ---------------------------- | ------------------ | -------------------------------- | -------------------- |
| 未提交读（Read uncommitted） | 可能               | 可能                             | 可能                 |
| 已提交读（Read committed）   | 不可能             | 可能                             | 可能                 |
| 可重复读（Repeatable read    | 不可能             | 不可能                           | 可能                 |
| 可串行化（Serializable ）    | 不可能             | 不可能                           | 不可能               |

- SQL 和 SQL2 标准的默认事务隔离级别是 SERIALIZABLE
- InnoDB 存储引擎默认支持的隔离级别是 REPEATABLE READ   
  - 但与标准 SQL 不同的是：通过使用 Next-Key Lock 锁的算法来避免幻读的产生
  - 即 InnoDB 在默认的默认隔离级别下已经能完全保证事务的隔离性要求（达到 SQL 标准的 SERIALIZABLE 级别)
- 在 SERIALIZABLE 的事务隔离级别，InnoDB 会对每个 SELECT 语句后自动加上 LOCK IN SHARE MODE,即共享读锁   
  - 因此在此隔离级别下，读占用了锁，对一致性的非锁定读不再予以支持
  - 此隔离级别复核数据库理论上的要求，即事务是 well-formed 的，并且是 two-phrased
  - SERIALIZABLE 的隔离级别主要用于 InnoDB 存储引擎的分布式事务
- 在 READ COMMITTED 的事务隔离级别下，除唯一性约束检查及外键约束检查需要 gap lock，其他情况都不会使用



#### 3.3.2 事务的分类

> MySQL 的 InnoDB 引擎是不支持嵌套事务的，在开启了一个事务的情况下，再开启一个事务，会隐式的提交上一个事务。
>
> Mysql  的 InnoDB 引擎，默认是 autocommit = 1，也就是说默认是立即提交，如果想开启事务，先设置 autocommit = 0，然后用 START TRANSACTION、 COMMIT、 ROLLBACK 来使用具体的事务。

##### 3.3.2.1 扁平事务

```sql
-- 在扁平事务中，所有操作都处于同一层次，其由BEGIN WORK开始，由 COMMIT WORK 或 ROLLBACK WORK 结束，其间的操作要么都执行，要么都回滚。
-- 缺点：不能提交或者回滚事务的某一部分，或分几个步骤提交。
BEGIN WORK
	Operation 1;
	Operation 2;
	...
	Operation k;
COMMIT WORK
```



##### 3.3.2.2 带有保存点的扁平事务

```sql
-- 隐式的设置了保存点，允许在事务执行过程中回滚同一事务中较早的一个状态
-- 缺点：系统崩溃时，保存点会消失，导致事务回滚后从头开始执行
BEGIN WORK
	Operation A;
	Operation B;
SAVE WORK: 1
	Operation C;
SAVE WORK: 2
	Operation D;
ROLLBACK WORK 1 / ROLLBACK WORK 2
```



##### 3.3.2.3 链事务

* 是带有保存点事务的变种，在提交一个事务时，会释放下一个事务不需要的对象（锁），并将自己的执行结果隐式地传递给下一个事物。
* 链事务与带有保存点事务的区别：
  * 链事务只能回滚到前一个事务的结果处，而带有保存点事务可以回滚到任意一个保存点处
  * 链事务的每个事务在执行完 COMMIT 后会释放自己所持有的锁，而带有保存点事务则会一直持有每个阶段的所，直至最终COMMIT

<img src="https://github.com/IvanBao97/Notes/blob/main/MySQL/NotePics/ChainTransaction.png" alt="image-链事务" style="zoom:50%;" />



##### 3.3.2.4 嵌套事务

```sql
-- 父事务中嵌套着子事务（并发事务）
BEGIN WORK
	Transaction 1;
	Transaction 2;
	...
	Transaction k;
COMMIT WORK

-- 测试在 InnoDB 引擎中使用嵌套事务
SELECT * FROM test;  
+-----+  
|  n  |  
+-----+  
|  1  |  
+-----+   
  
START TRANSACTION;

INSERT INTO test VALUES(2);  

START TRANSACTION; 
  
INSERT INTO test VALUES(3); 
  
COMMIT;  

ROLLBACK;  

SELECT * FROM test;  
+-----+  
|  n  |  
+-----+  
|  1  |  
|  2  |  
|  3  |  
+-----+  

-- MySQL 的 InnoDB 引擎是不支持嵌套事务的，在开启了一个事务的情况下，再开启一个事务，会隐式的提交上一个事务。
```



##### 3.3.2.5 分布式事务

* 在分布式环境下的扁平事务，在调用多台数据的情况下，同样需要满足事务的 ACID 特性。（详细见分布式事务篇）

<br>

#### 3.4 事务的控制语句

```sql
BEGIN|START TRANSACTION
-- 显式的开启一个事务

COMMIT|COMMIT WORK
-- 都用来提交事务，不同的在于 COMMIT WORK 用来控制事务提交后的行为是 CHAIN 还是 RELEASE 的。如果是 CHAIN 方式，那么事务就变成了链事务。可以通过参数 completion_type 来进行控制，默认为 0 表示没有任何操作，这种时候 COMMIT 和 COMMIT WORK 是完全等价的。为 1 时 COMMIT WORK 等同于 COMMIT AND CHAIN,表示马上开启一个相同隔离级别的事务。为 2 时 COMMIT WORK 等同于 COMMIT AND RELEASE，当事务提交后自动与服务器断开连接。

ROLLBACK|ROLLBACK WORK
-- 都用来回滚事务。结束正在执行的事务，并撤销所有还没提交的修改。


 
SAVEPOINT identifier
-- SAVEPOINE 允许在事务当中创建一个保存点，一个事务中可以创建多个保存点。

RELEASE SAVEPOINT identifier
-- 删除事务的一个保存点，当没有一个该保存点时抛出异常。

ROLLBACK TO [SAVEPOINT] identifier
-- 与 SAVEPOINT identifier 配合使用，用来将事务回滚到某个 identifier 的状态。

SET TRANSACTION
-- 设置事务的隔离级别，InnoDB 中提供了 READ UNCOMMITTED，READ COMMITTED，REPEATABLE READ，SERIALIZABLE 四种隔离级别。InnoDB 默认为 REPEATABLE READ。
```

<br>

#### 3.5 分布式事务

* 本质：分布式事务就是为了保证不同数据库的数据一致性。





<br>

#### 3.6 使用事务的注意点

* **在循环中提交事务**

  * 当我们需要在循环操作中提交事务时，就需要根据实际情况来选择事务范围
    * 每循环一次，做一次事务的提交。
      * 效率低，但回滚代价小
    * 所有循环操作，在一个事务里提交。
      * 效率高，但回滚代价大

* **自动提交事务或自动回滚**

  * InnoDB 引擎是默认开启事务自动提交的，我们可以选择关闭自动提交

    ```sql
    SET autocommit = 0 -- 关闭自动提交事务
    ```

  * 事务的提交和回滚时机可以交由程序开发者来处理，从而方便根据业务和需求设计不同的事务提交模式，同时，在发生错误回滚时，也可以得知发生错误的原因和定位。

* **运行长事务**
  * 问题：长事务由于执行过程较长，很可能在执行过程中遇到数据库、操作系统或硬件的问题，使得事务回滚，而重新开始执行就会使得代价过大。
  * 解决：将长事务转化为小批量的事务处理
    * 每完成一个小事务，都将完成的结果存在 batchContext 中，记录完成批量事务中的最大账号 ID，如果遇到问题回滚，我们只需要找到已完成的最大事务 ID，继续执行，从而减少重新执行的代价。

<br>

<br>

## 4. MySQL 基准测试





## 5. MySQL 性能优化

### 5.1 服务器性能优化



<br>

### 5.2 Schema 与数据类型的优化

#### 5.2.1 数据类型的设计

基本原则：

1. 更小的通常更好
   * 在满足存储需求的前提下，更小的数据类型会占用更少的磁盘、内存和 CPU 缓存，CPU 处理周期也就越短
2. 越简单的数据类型越好
   * 简单的数据类型通常需要更少的 CPU 处理周期，例如整形比字符操作代价更低，因为字符集和校对规则（排序规则）会使字符操作更复杂
3. 尽量避免 NULL
   * 如果不是需要存储 NULL 值得情况下，最好将列定为 NOT NULL。因为如果查询中包含可为 NULL 的列，会使索引、索引统计和值比较变得更复杂
     * 索引记录会额外使用一个字节来记录 NULL



##### 5.2.1.1 实数类型

**【整数类型】**

|   类型    | 存储空间大小 (n) | 范围 (-2 ^(n-1)^ ~ 2 ^(n-1)^ - 1) |
| :-------: | :--------------: | :-------------------------------: |
|  TINYINT  |       8 位       |            -128 ~ 127             |
| SMALLINT  |      16 位       |       -2 ^15^ ~ 2 ^15^ - 1        |
| MEDIUMINT |      24 位       |       -2 ^23^ ~ 2 ^23^ - 1        |
|    INT    |      32 位       |       -2 ^31^ ~ 2 ^31^ - 1        |
|  BIGINT   |      64 位       |       -2 ^63^ ~ 2 ^63^ - 1        |

UNSIGNED 属性：表示不允许负值，可以使正数上限扩大一倍

* Eg：TINYINT UNSIGNED 0 ~ 255， TINYINT -128 ~ 127

为整数类型设置宽度是没有意义的，它并不会限制实际的合法范围。宽度只是控制类数据的展示个数，对于存储和计算没有影响

**【小数类型】** 

|  类型   | 存储空间大小 | 计算类型 |          计算代价          |
| :-----: | :----------: | :------: | :------------------------: |
| DOUBLE  |    8 字节    | 近似计算 | 小（CPU 原生支持浮点运算） |
|  FLOAT  |    4 字节    | 近似计算 | 小（CPU 原生支持浮点运算） |
| DECIMAL |      -       | 精准计算 |             大             |

建议在使用小数类型时，只指定数据类型，而不指定数据精度

需要使用小数存储和精准计算时，可以先将数据放大 X 倍，使用 BIGINT 存储，计算完成后，将结果再缩小 X 倍



##### 5.2.1.2 字符串类型

**【VARCHAR | CHAR】**

|              |                           VARCHAR                            |                           CHAR                           |
| :----------: | :----------------------------------------------------------: | :------------------------------------------------------: |
| **存储特点** | 1. 存储 **变长** 字符串 <br> 2. 需要额外使用额外字节记录字符串长度（未超过255字节为1，超过为2） | 1. 存储 **定长** 字符串 <br> 2. 会删除存储内容尾部的空格 |
|   **优点**   |                     仅使用必要的存储空间                     |                      不容易产生碎片                      |
|   **缺点**   |    1. 容易产生碎片 <br> 2. 更新变得更长时可能会导致页分裂    |                  更新时无法扩展字段长度                  |
| **使用场景** | 1. 列更新频率低 <br> 2. 列使用了 UTF-8 之类的复杂字符集（每个字符使用不同字节数存储） |               列存储长度短且固定（MD5 值）               |

**【BLOB | TEXT】**

BLOB 和 TEXT 都是为存储很大的数据而设计的字符串数据类型

* BLOB：采用二进制方式存储，没有排序规则和字符集
* TEXT：采用字符方式存储

MySQL 会将它们作为一个独立的对象处理，当它们过大时，InnoDB 会使用外部存储区域来存储实际数据值，内部只保留一个 1~4 字节的指针

==**问题**==：使用 ORDER BY 命令时，会扫描整个表，并将结果存储在临时表中（见 EXPLAIN 的 Extra 列包含 Using temporary），如果目标是占用空间较大的列（如 BLOB | TEXT | VARCHAR(1000) 等），就会使得临时表占用多空间

==**解决**==：使用 ORDER BY SUBSTRING (column, length) 命令将待比较的列值转换为截取字符串，有效减小临时表的大小



##### 5.2.1.3 日期和时间类型

|              |      DATETIME       |                     TIMESTAMP（时间戳）                      |
| :----------: | :-----------------: | :----------------------------------------------------------: |
| **时间范围** |   1001年 — 9999年   |                       1970年 — 2038年                        |
| **存储空间** |       8 字节        |                            4 字节                            |
| **时区影响** |         无          |     有（与MySQL 服务器、操作系统、客户端连接的时区有关）     |
| **显示格式** | yyyy-mm-dd hh:mm:ss | 1970年1月1日0点0分0秒至今的秒数 <br> MySQL 内部提供了 FROM_UNIXTIME() 函数将时间戳转换为日期 |



#### 5.2.2 Schema 的设计

##### 增加冗余字段和冗余表

增加冗余字段和冗余表的本质就是反范式化

优点：这样可以有效的减少关联查询，同时利用索引，优化读操作。

缺点：在进行写操作时，字段和表的维护变得更加困难



##### 避免 ALERT TABLE 的操作

MySQL 的 ALERT TABLE 操作非常影响性能，因为该操作会锁住整个表，具体过程如下：

1. 用修改后的新结构创建一个新的空表
2. 从旧表中查出所有数据插入新表
3. 最后删除旧表

解决方法：

* 主库调换法：先在一台不提供服务的机器上执行 ALERT TABLE 操作，然后再和主库替换
* 影子拷贝法：
  * 在主服务器上建立新的表，新表结构就是要修改老表之后的结构，然后把老表数据导入新表
  * 同时在老表建立一系列触发器，把老表的数据修改同步到新表
  * 当老表和新表的数据同步后再对老表建立一个排它锁，然后重新命名新表为老表的名字，最后删除后命名的老表。
  * 这样做的好处可以减少主从延迟，并且可以借助 pt-onlinee-schema-change 工具完成操作



<br>

### 5.3 索引优化

#### 概念

* 索引的目的是**提高查询效率**，本质上是一种**排好序**的**数据结构**

  * B Tree

    * m 叉 B 树每个节点最多有 m-1 个元素
    * 所有索引元素无重复
  * 叶节点之间没有指针

  <img src="https://github.com/IvanBao97/Notes/blob/main/MySQL/NotePics/BTree.png" alt="image-BTree" style="zoom:50%;" />

  

* B+ Tree (默认)

  * m 叉 B+ 树每个节点最多有 m 个元素
  * 非叶子节点**不存储 Data，只存储索引**，因此可以放更多的索引
  * 叶子节点包含**所有索引字段**
    * 叶子节点用指针连接，提高区间访问性能

  <img src="https://github.com/IvanBao97/Notes/blob/main/MySQL/NotePics/B%2BTree.png" alt="image-B+Tree" style="zoom:50%;" />

  

  * Hash
    * 对索引的 key 进行一次 hash 计算就可以定位 Data 存储位置
  * 就单一查询来说，性能优于 B+ Tree
    * 无法进行范围查找，且存在 hash 冲突问题

  <img src="https://github.com/IvanBao97/Notes/blob/main/MySQL/NotePics/Hash.png" alt="image-Hash" style="zoom:50%;" />



#### 优势和劣势

* 优势
  * 提高数据检索效率，降低数据排序成本
* 劣势
  * 索引本质上也是一张表，需要占用额外的空间
  * 索引虽然提高了查询速度，但会严重影响 INSERT, UPDATE, DELETE 速度。因为更新表时，MySQL 不仅需要保存数据，还需要更新索引指向



#### 索引分类

* 单值索引：一个索引只包含单个列，一个表可以有多个单值索引
* 唯一索引：索引列的值必须唯一，但允许有空置（主键就是唯一索引）
* 复合索引：一个索引包含多个列



#### 如何使用索引

* 使用语法

  ```mysql
  CREATE INDEX idxName ON tableName(colName1, colName2, ...)
  ```

* 适合建立索引的情况

  * **主键自动建立唯一索引**
  * 频繁作为查询条件的字段应该建立索引
  * 查询排序的字段

* 不适合建立索引的情况

  * 表记录过少
  * 表的字段需要经常被修改
  * 表的字段数据重复且分布均匀（例如：性别字段，只有男女两个数据且分布均匀）

<br>

### 5.4 查询性能优化



<br>

### 5.5 MySQL 高级特性



<br>

### 5.6 操作系统和硬件优化



<br>

<br>

## 6. 复制

